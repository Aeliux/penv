#!/usr/bin/env bash

# Penv command-line tool

# import metadata
if [ -f /penv/metadata.sh ]; then
    . /penv/metadata.sh
else
    echo "Error: /penv/metadata.sh not found" >&2
    exit 1
fi

penv::version() {
    echo "$PENV_VERSION"
}

penv::requires_version() {
    local required_version="$1"
    if [ -z "$required_version" ]; then
        echo "Error: No version specified" >&2
        return 1
    fi

    local ver1="$PENV_VERSION"
    local ver2="$required_version"

    # Pad the shorter version with zeros
    local IFS=.
    read -r -a ver1_parts <<< "$ver1"
    read -r -a ver2_parts <<< "$ver2"
    local len1=${#ver1_parts[@]}
    local len2=${#ver2_parts[@]}
    local max_len=$(( len1 > len2 ? len1 : len2 ))
    for ((i=len1; i<max_len; i++)); do
        ver1_parts[i]=0
    done
    for ((i=len2; i<max_len; i++)); do
        ver2_parts[i]=0
    done
    ver1="${ver1_parts[*]}"
    ver2="${ver2_parts[*]}"
    ver1=${ver1// /./}
    ver2=${ver2// /./}
    
    # Compare using sort -V
    local sorted_versions
    sorted_versions=$(printf "%s\n%s\n" "$ver1" "$ver2")
    sorted_versions=$(echo "$sorted_versions" | sort -V)
    
    if [[ "$(echo "$sorted_versions" | head -n1)" == "$ver2" ]]; then
        return 0
    else
        return 1
    fi
}

penv::clean(){
    # requires version 2 and PENV_SIGNAL to be set
    if penv::requires_version 2 && [ -n "$PENV_SIGNAL" ]; then
        local signal_file="$PENV_SIGNAL/clean_signal_$$"
        cat > "$signal_file" << EOF
export PENV_SIGNAL_CLEANUP=1
export PENV_CONFIG_VERBOSE=1
EOF
        chmod +x "$signal_file"
        echo "Cleanup will be performed after ending the session."
        return 0
    else
        echo "Error: not supported in this environment" >&2
        return 1
    fi
}

# Simple argparser that maps commands to functions
penv::main() {
    local cmd="$1"
    shift || true

    local func="penv::${cmd//-/_}"
    if command -v "$func" >/dev/null 2>&1; then
        "$func" "$@"
        return $?
    else
        if [ -n "$cmd" ]; then
            echo "Error: Unknown command: $cmd" >&2
        fi

        # Iterate through all available commands
        echo "Available commands are:"
        local available_cmds
        available_cmds=$(declare -F | awk '{print $3}' | grep '^penv::' | sed 's/^penv:://')
        for acmd in $available_cmds; do
            if [ "$acmd" = "main" ]; then
                continue
            fi
            echo "  $acmd"
        done

        return 1
    fi
}

# Execute main function with all arguments
penv::main "$@"